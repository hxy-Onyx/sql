先创建一个练习表

CREATE TABLE employees (
    employee_id NUMBER,
    employee_name VARCHAR2(50),
    department VARCHAR2(50),
    location VARCHAR2(50),
    salary NUMBER,
    years_of_experience NUMBER
);

INSERT INTO employees (employee_id, employee_name, department, location, salary, years_of_experience) VALUES (1, 'John', 'Sales', 'New York', 50000, 5);
INSERT INTO employees (employee_id, employee_name, department, location, salary, years_of_experience) VALUES (2, 'Alice', 'Sales', 'New York', 60000, 6);
INSERT INTO employees (employee_id, employee_name, department, location, salary, years_of_experience) VALUES (3, 'Bob', 'HR', 'London', 70000, 8);
INSERT INTO employees (employee_id, employee_name, department, location, salary, years_of_experience) VALUES (4, 'Cathy', 'HR', 'London', 80000, 10);
INSERT INTO employees (employee_id, employee_name, department, location, salary, years_of_experience) VALUES (5, 'David', 'IT', 'New York', 75000, 4);


1. where和having在使用聚合函数时的错误
有where子句的存在就不能使用聚合函数，
having可以使用聚合函数
举例：
错误示例：
SELECT department, COUNT(*)
FROM employees
GROUP BY department
WHERE COUNT(*) > 1;  -- 错误：WHERE 不能过滤聚合结果

正确做法：
SELECT department, COUNT(*)
FROM employees
GROUP BY department
HAVING COUNT(*) > 1;  -- 使用 HAVING 来过滤聚合结果

原因：where的作用是在分组前过滤数据
having是和group by合用，用来计算分组后的数据
而聚合函数的结果，是group by之后的计算结果
所以where不能使用聚合函数，即使没有group by where也不能使用聚合函数

2. group by子句对select的限制
SELECT 中的所有列要么必须在 GROUP BY 中，要么必须使用聚合函数。
如果在 SELECT 中选择了未在 GROUP BY 中的列，SQL 会报错。
举例：
错误示例：
SELECT department, employee_name, COUNT(*)
FROM employees
GROUP BY department;  -- 错误：employee_name 没有在 GROUP BY 中
正确做法：

SELECT department, MAX(employee_name), COUNT(*)
FROM employees
GROUP BY department;  -- 使用聚合函数 MAX() 来处理未分组的列
为什么：
这显示了group by子句对select的限制：这是因为数据库无法确定如何处理这些未分组或未聚合的列的数据。
数据库会将查询结果按指定的列进行分组。对于每个分组，数据库需要确定如何处理 SELECT 中的每一列，
对于未出现在 GROUP BY 中且未使用聚合函数的列，数据库无法确定在每个分组中应该返回哪一行的数据。


3. 使用 HAVING 而不是 WHERE 来过滤非聚合条件
问题： HAVING 通常用于过滤聚合结果，而 WHERE 用于过滤非聚合列。如果你在 HAVING 中使用非聚合条件，会导致性能下降。

错误示例：
SELECT department, COUNT(*)
FROM employees
GROUP BY department
HAVING department = 'Sales';  -- 错误：这是非聚合条件，应该用 WHERE
正确做法：


SELECT department, COUNT(*)
FROM employees
WHERE department = 'Sales'  -- 使用 WHERE 过滤非聚合列
GROUP BY department;

为什么：
WHERE 子句过滤在分组之前，减少了需要分组和聚合的数据量，从而提高查询性能。
HAVING 子句过滤在分组之后，意味着所有行都必须先被分组和聚合，之后再进行过滤，这会增加不必要的计算和资源消耗，导致性能下降。
逻辑上，非聚合条件属于数据筛选的基本步骤，应该在分组之前完成。将其放在 HAVING 中，不仅违反了 SQL 的逻辑顺序，还可能导致理解上的混淆

4. 在 HAVING 中使用错误的聚合函数
问题： 在 HAVING 子句中过滤分组时，聚合函数的使用必须正确，否则会得到不符合预期的结果。

错误示例：
SELECT department, SUM(salary)
FROM employees
GROUP BY department
HAVING COUNT(salary) > 5;  -- 错误：我们想过滤工资总和，但用错了聚合函数

正确做法：
SELECT department, SUM(salary)
FROM employees
GROUP BY department
HAVING SUM(salary) > 100000;  -- 使用 SUM() 来正确过滤工资总和

5. GROUP BY 后的 ORDER BY 问题
问题： 在使用 GROUP BY 后进行排序时，开发者可能错误地使用了非聚合列进行排序，导致结果与预期不符。

错误示例：
SELECT department, COUNT(*)
FROM employees
GROUP BY department
ORDER BY department DESC;  -- 错误：我们应该按聚合结果排序，而不是按部门名

正确做法：
SELECT department, COUNT(*) AS employee_count
FROM employees
GROUP BY department
ORDER BY employee_count DESC;  -- 按聚合结果（员工数量）排序

6. 使用 HAVING 代替 WHERE 影响性能
问题： WHERE 是在分组之前执行的，而 HAVING 是在分组之后执行。如果你在 HAVING 中使用非聚合条件，可能会导致性能问题。

错误示例：
SELECT department, COUNT(*)
FROM employees
GROUP BY department
HAVING department = 'IT';  -- 错误：应该使用 WHERE
正确做法：
SELECT department, COUNT(*)
FROM employees
WHERE department = 'IT'  -- 使用 WHERE 来过滤非聚合条件
GROUP BY department;

7. 忽略空值（NULL）处理
问题： 在分组时，GROUP BY 会将 NULL 值视为一个独立的分组。如果你不想要 NULL 值成为单独的一组，必须处理 NULL 值。

解决方法：
SELECT COALESCE(department, 'Unknown') AS department, COUNT(*)
FROM employees
GROUP BY department;

8. GROUP BY 时的性能问题
在处理大数据时，GROUP BY 操作可能很耗时。如果分组列没有索引，查询性能会受到影响。

优化建议：
在需要分组的列上创建索引。
避免不必要的复杂分组，减少 GROUP BY 中的列数。

9. 多列分组中的细节处理
在使用 GROUP BY 时，如果你想按多个列分组，每个列的组合都会产生一个独立的分组。如果你不需要这些组合，可能会产生不必要的复杂性。

示例：
SELECT department, location, COUNT(*)
FROM employees
GROUP BY department, location;  -- 每个部门和地点的组合生成一个分组
如果你只想按部门分组，而不需要按地点分组，则可以省略 location：


SELECT department, COUNT(*)
FROM employees
GROUP BY department;

