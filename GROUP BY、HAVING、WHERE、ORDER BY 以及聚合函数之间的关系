先创建一个练习表

CREATE TABLE employees (
    employee_id NUMBER,
    employee_name VARCHAR2(50),
    department VARCHAR2(50),
    location VARCHAR2(50),
    salary NUMBER,
    years_of_experience NUMBER
);

INSERT INTO employees (employee_id, employee_name, department, location, salary, years_of_experience) VALUES (1, 'John', 'Sales', 'New York', 50000, 5);
INSERT INTO employees (employee_id, employee_name, department, location, salary, years_of_experience) VALUES (2, 'Alice', 'Sales', 'New York', 60000, 6);
INSERT INTO employees (employee_id, employee_name, department, location, salary, years_of_experience) VALUES (3, 'Bob', 'HR', 'London', 70000, 8);
INSERT INTO employees (employee_id, employee_name, department, location, salary, years_of_experience) VALUES (4, 'Cathy', 'HR', 'London', 80000, 10);
INSERT INTO employees (employee_id, employee_name, department, location, salary, years_of_experience) VALUES (5, 'David', 'IT', 'New York', 75000, 4);


1. where和having在使用聚合函数时的错误
where的作用是在分组前过滤数据
having是和group by合用，用来数据
而聚合函数的结果，是group by之后的计算结果
所以where不能使用聚合函数，即使没有group by where也不能使用聚合函数

错误示例：
SELECT department, COUNT(*)
FROM employees
GROUP BY department
WHERE COUNT(*) > 1;  -- 错误：WHERE 不能过滤聚合结果

正确做法：
SELECT department, COUNT(*)
FROM employees
GROUP BY department
HAVING COUNT(*) > 1;  -- 使用 HAVING 来过滤聚合结果

2. 选择的列不在 GROUP BY 中
SELECT 中的所有列要么必须在 GROUP BY 中，要么必须使用聚合函数。如果你在 SELECT 中选择了未在 GROUP BY 中的列，SQL 会报错。
这显示了groupby子句对select的限制：这是因为数据库无法确定如何处理这些未分组或未聚合的列的数据。

为什么：
数据库会将查询结果按指定的列进行分组。对于每个分组，数据库需要确定如何处理 SELECT 中的每一列，
对于未出现在 GROUP BY 中且未使用聚合函数的列，数据库无法确定在每个分组中应该返回哪一行的数据。

错误示例：
SELECT department, employee_name, COUNT(*)
FROM employees
GROUP BY department;  -- 错误：employee_name 没有在 GROUP BY 中
正确做法：

SELECT department, MAX(employee_name), COUNT(*)
FROM employees
GROUP BY department;  -- 使用聚合函数 MAX() 来处理未分组的列
这里：如果又想分组，但是又想展示所有的列信息，应该怎么办
可以使用order by

3. 使用 HAVING 而不是 WHERE 来过滤非聚合条件
问题： HAVING 通常用于过滤聚合结果，而 WHERE 用于过滤非聚合列。如果你在 HAVING 中使用非聚合条件，会导致性能下降。

错误示例：
SELECT department, COUNT(*)
FROM employees
GROUP BY department
HAVING department = 'Sales';  -- 错误：这是非聚合条件，应该用 WHERE
正确做法：


SELECT department, COUNT(*)
FROM employees
WHERE department = 'Sales'  -- 使用 WHERE 过滤非聚合列
GROUP BY department;

4. 在 HAVING 中使用错误的聚合函数
问题： 在 HAVING 子句中过滤分组时，聚合函数的使用必须正确，否则会得到不符合预期的结果。

错误示例：
SELECT department, SUM(salary)
FROM employees
GROUP BY department
HAVING COUNT(salary) > 5;  -- 错误：我们想过滤工资总和，但用错了聚合函数

正确做法：
SELECT department, SUM(salary)
FROM employees
GROUP BY department
HAVING SUM(salary) > 100000;  -- 使用 SUM() 来正确过滤工资总和

5. GROUP BY 后的 ORDER BY 问题
问题： 在使用 GROUP BY 后进行排序时，开发者可能错误地使用了非聚合列进行排序，导致结果与预期不符。

错误示例：
SELECT department, COUNT(*)
FROM employees
GROUP BY department
ORDER BY department DESC;  -- 错误：我们应该按聚合结果排序，而不是按部门名

正确做法：
SELECT department, COUNT(*) AS employee_count
FROM employees
GROUP BY department
ORDER BY employee_count DESC;  -- 按聚合结果（员工数量）排序

6. 使用 HAVING 代替 WHERE 影响性能
问题： WHERE 是在分组之前执行的，而 HAVING 是在分组之后执行。如果你在 HAVING 中使用非聚合条件，可能会导致性能问题。

错误示例：
SELECT department, COUNT(*)
FROM employees
GROUP BY department
HAVING department = 'IT';  -- 错误：应该使用 WHERE
正确做法：
SELECT department, COUNT(*)
FROM employees
WHERE department = 'IT'  -- 使用 WHERE 来过滤非聚合条件
GROUP BY department;

7. 忽略空值（NULL）处理
问题： 在分组时，GROUP BY 会将 NULL 值视为一个独立的分组。如果你不想要 NULL 值成为单独的一组，必须处理 NULL 值。

解决方法：
SELECT COALESCE(department, 'Unknown') AS department, COUNT(*)
FROM employees
GROUP BY department;

8. GROUP BY 时的性能问题
在处理大数据时，GROUP BY 操作可能很耗时。如果分组列没有索引，查询性能会受到影响。

优化建议：
在需要分组的列上创建索引。
避免不必要的复杂分组，减少 GROUP BY 中的列数。

9. 多列分组中的细节处理
在使用 GROUP BY 时，如果你想按多个列分组，每个列的组合都会产生一个独立的分组。如果你不需要这些组合，可能会产生不必要的复杂性。

示例：
SELECT department, location, COUNT(*)
FROM employees
GROUP BY department, location;  -- 每个部门和地点的组合生成一个分组
如果你只想按部门分组，而不需要按地点分组，则可以省略 location：


SELECT department, COUNT(*)
FROM employees
GROUP BY department;

