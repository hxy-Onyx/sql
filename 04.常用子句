create table student(
	id int not null default 1,
	name varchar(20) not null default '',
	chinese float not null default 0.0,
	english float not null default 0.0,
	math float not null default 0.0
);

insert into student(id,name,chinese,english,math) values(1,'韩顺平',89,78,90);
insert into student(id,name,chinese,english,math) values(2,'张飞',67,98,56);
insert into student(id,name,chinese,english,math) values(3,'宋江',87,78,77);
insert into student(id,name,chinese,english,math) values(4,'关羽',88,98,90);
insert into student(id,name,chinese,english,math) values(5,'赵云',82,84,67);
insert into student(id,name,chinese,english,math) values(6,'欧阳锋',55,85,45);
insert into student(id,name,chinese,english,math) values(7,'黄蓉',75,65,30);
基于上表学习
1. WHERE 子句
示例 1：查询语文成绩大于 80 分的学生

SELECT name, chinese 
FROM student
WHERE chinese > 80;

示例 2：查询所有数学成绩小于 60 分的学生
SELECT name, math 
FROM student
WHERE math < 60;
--------------------------
2. GROUP BY 和 HAVING 子句
GROUP BY 子句用于将数据按某些列进行分组，常与聚合函数（如 SUM()、AVG()、COUNT() 等）一起使用。
HAVING 子句用于对分组后的结果进行筛选，它常用于替代 WHERE，但只能对分组后的结果进行操作。

示例 1：按部门（例如语文成绩）分组，统计各分数段学生的数量
SELECT 
    CASE 
        WHEN chinese >= 80 THEN '80分以上'
        WHEN chinese >= 60 THEN '60-79分'
        ELSE '60分以下'
    END AS score_range,
    COUNT(*) AS num_students
FROM student
GROUP BY score_range;

示例 2：按语文成绩分组，筛选分组后人数超过 1 的分数段
SELECT 
    CASE 
        WHEN chinese >= 80 THEN '80分以上'
        WHEN chinese >= 60 THEN '60-79分'
        ELSE '60分以下'
    END AS score_range,
    COUNT(*) AS num_students
FROM student
GROUP BY score_range
HAVING COUNT(*) > 1;
---------------------------------------
3. ORDER BY 子句
ORDER BY 子句用于对查询结果按指定的列进行排序，默认是升序（ASC），如果需要降序，可以使用 DESC。

示例 1：按语文成绩降序排列学生
SELECT name, chinese 
FROM student
ORDER BY chinese DESC;

示例 2：按总分降序排列学生，并显示每个学生的总分
SELECT name, (chinese + english + math) AS total_score 
FROM student
ORDER BY total_score DESC;
-------------------------------------------
总结：
WHERE 子句：用于对查询数据进行筛选，返回符合条件的记录。
GROUP BY 和 HAVING 子句：GROUP BY 按照指定列进行分组，HAVING 用于筛选分组后的结果，通常与聚合函数一起使用。
ORDER BY 子句：用于对查询结果进行排序，可以升序或降序排列。

